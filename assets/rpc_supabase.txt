-- Criação da stored procedure que pega todos os eventos em que o project.user_id = parametro fornecido (id do usuário)
CREATE OR REPLACE FUNCTION get_project_summary(parametro_id BIGINT)
RETURNS TABLE (
    project_name VARCHAR(30),
    project_id BIGINT,
    event_id BIGINT,
    subtotal NUMERIC(9,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.name AS project_name,
        p.id AS project_id,
        p.id AS event_id,
        COALESCE(SUM(si.price * pi.qty), 0) AS subtotal
    FROM project p
    LEFT JOIN project_item pi ON p.id = pi.project_id
    LEFT JOIN supplier_item si ON pi.product_id = si.id
    WHERE p.user_id = parametro_id
    GROUP BY p.id;
END;
$$ LANGUAGE plpgsql;

select * from get_project_summary(10);

/*FUNCIONAAAAAAAAAAAAAAAA*/
/* 100% confiável */











-- criação da stored procedure que pega o id do usuário autenticado
CREATE OR REPLACE FUNCTION get_app_user_id(parametro_uuid uuid)
RETURNS TABLE(id bigint) AS $$
BEGIN
    RETURN QUERY
    SELECT app_user.id
    FROM app_user
    WHERE app_user.user_uuid = parametro_uuid;
END;
$$ LANGUAGE plpgsql;

/* funciona, é 100% confiável */










create or replace function public.filter_products(filtro_produtos text default null)
returns table(
    product_id bigint,
    supplier_id bigint,
    supplier_company varchar,
    nameproduct varchar,
    descproduct varchar,
    price numeric,
    product_url text,
    category varchar,
    qty_in_store smallint
)
language sql
as $$
  select 
    si.id as product_id,
    si.supplier_id,
    sd.company_name as supplier_company,
    si.nameproduct,
    si.descproduct,
    si.price,
    si.product_url,
    si.category,
    si.qty_in_store
  from 
    public.supplier_item si
  join 
    public.supplier_details sd
  on 
    si.supplier_id = sd.id
  where 
    filtro_produtos is null or si.nameproduct ilike '%' || filtro_produtos || '%';
$$;

-- select * from public.filter_products();
-- select * from public.filter_products('filtro');

-- FUNCIONA PERFEITAMENTE
